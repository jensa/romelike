<html>
  <body>
    <div style="width: 100%; text-align: center">
      <canvas
        style="margin-left: auto; margin-right: auto"
        id="canvas"
        width="700"
        height="900"
      >
      </canvas>
    </div>
    <script type="text/javascript">
      window.onload = function () {
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // draw the grid empty (maybe with enemies?)
        //how the game loop works:
        // draw 5 cards
        // when card is chosen, draw overlay on the bottom grid row and the card's attack pattern
        // when one of the bottom grid squares is chosen, draw the cards unit on that square
        // your guys attack, then move (?)
        // let enemies attack, then move, the draw 5 new cards
        const states = ["choose_card", "consider_card", "other"];
        let currentstate = states[0];
        let drawn = [];
        let enemyDrawn = [];
        let selectedCard;
        let discard = [];
        let enemyDiscard = [];
        let combatLog = [];
        let overlainGridBox;
        let overlainTroopBox;
        let enemyHp = 10;
        let yourHp = 10;
        let gameOverText;
        let troops = [];
        let cards = [
          makeCard("legion", false),
          makeCard("legion", false),
          makeCard("archer", false),
          makeCard("legion", false),
          makeCard("archer", false),
          makeCard("shield", false),
          makeCard("legion", false),
          makeCard("berserk", false),
        ];

        let enemyCards = [
          makeCard("knight", true),
          makeCard("legion", true),
          makeCard("archer", true),
          makeCard("legion", true),
          makeCard("archer", true),
          makeCard("shield", true),
          makeCard("legion", true),
          makeCard("berserk", true),
        ];

        shuffleArray(cards);
        shuffleArray(enemyCards);
        drawCards(ctx, cards, discard);
        drawEnemyCards();
        placeEnemyTroops();
        render();
        function render() {
          renderDrawn(ctx, drawn);
          renderTroops(troops);
          drawGrid(ctx);
          renderEndOfGame();
        }

        function renderEndOfGame() {
          if (gameOverText) {
            ctx.font = "100px Arial";
            ctx.fillStyle = "red";
            ctx.fillText(gameOverText, 100, 200);
          }
        }

        function renderTroops(troops) {
          troops.forEach((troop) => {
            let pos = grid2Pixel(troop);
            ctx.strokeStyle = troop.enemy ? "purple" : "green";
            ctx.beginPath();
            ctx.rect(pos.x + 10, pos.y + 10, 80, 80);
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.fillText(troop.name, pos.x + 20, pos.y + 40);
            if (troop.enemy) {
              renderPattern(troop);
            }
          });
          if (overlainTroopBox) {
            let pos = grid2Pixel(overlainTroopBox);
            ctx.strokeStyle = "blue";
            ctx.beginPath();
            ctx.rect(pos.x + 10, pos.y + 10, 80, 80);
            ctx.stroke();
            ctx.fillStyle = "black";
            ctx.fillText(overlainTroopBox.name, pos.x + 20, pos.y + 40);
            renderPattern(overlainTroopBox);
          }
        }

        function renderPattern(overlainTroopBox) {
          let pos = grid2Pixel(overlainTroopBox);
          ctx.strokeStyle = "blue";
          ctx.beginPath();
          ctx.rect(pos.x + 10, pos.y + 10, 80, 80);
          ctx.stroke();
          ctx.fillStyle = "black";
          ctx.fillText(overlainTroopBox.name, pos.x + 20, pos.y + 40);

          let lastXmod = 0;
          let lastYmod = 0;
          overlainTroopBox.movePattern.forEach((moveSquare) => {
            ctx.fillStyle = "rgb(200,200,200,0.3)";
            let movePos = {
              x: overlainTroopBox.x + lastXmod + moveSquare.x,
              y: overlainTroopBox.y + lastYmod + moveSquare.y,
            };
            let pixelPos = grid2Pixel(movePos);
            lastXmod += moveSquare.x;
            lastYmod += moveSquare.y;
            if (!overlainTroopBox.enemy) {
              ctx.fillRect(pixelPos.x, pixelPos.y, 100, 100);
            } else if (movePos.y < 5) {
              ctx.fillRect(pixelPos.x, pixelPos.y, 100, 100);
            }
          });

          overlainTroopBox.attackPattern.forEach((attackSquare) => {
            ctx.fillStyle = "rgb(255,0,0,0.5)";
            let attackPos = {
              x: overlainTroopBox.x + lastXmod + attackSquare.x,
              y: overlainTroopBox.y + lastYmod + attackSquare.y,
            };
            let attackPixelPos = grid2Pixel({
              x: overlainTroopBox.x + lastXmod + attackSquare.x,
              y: overlainTroopBox.y + lastYmod + attackSquare.y,
            });
            if (!overlainTroopBox.enemy) {
              ctx.fillRect(attackPixelPos.x, attackPixelPos.y, 100, 100);
            } else if (attackPos.y < 5) {
              ctx.fillRect(attackPixelPos.x, attackPixelPos.y, 100, 100);
            }
          });
        }

        function renderDrawn(ctx, drawn) {
          ctx.font = "15px Arial";
          ctx.strokeStyle = "red";
          ctx.lineWidth = "1";
          drawn.sort((a, b) => a.order - b.order);
          drawn.forEach((card, i) => {
            const x = i * 100 + 30;
            ctx.strokeStyle = card.filled ? "red" : "black";
            ctx.beginPath();
            ctx.rect(x, 520, 60, 100);
            ctx.stroke();
            ctx.strokeStyle = "black";
            ctx.fillStyle = "black";
            ctx.fillText(card.name, x + 10, 550);
          });
        }

        function drawCards(ctx, cards, discard) {
          if (cards.length > 4) {
            drawn = cards.splice(0, 5);
          } else {
            drawn = cards.splice(0, cards.length);
            cards = [...discard];
            shuffleArray(cards);
            drawn = [...drawn, ...cards.splice(0, 5 - drawn.length)];
          }
          drawn = drawn.map((d, i) => {
            return { ...d, order: i };
          });
        }

        function drawEnemyCards() {
          if (enemyCards.length > 4) {
            enemyDrawn = enemyCards.splice(0, 5);
          } else {
            enemyDrawn = enemyCards.splice(0, enemyCards.length);
            enemyCards = [...enemyDiscard];
            enemyDiscard = [];
            shuffleArray(enemyCards);
            enemyDrawn = [
              ...enemyDrawn,
              ...enemyCards.splice(0, 5 - enemyDrawn.length),
            ];
          }
          enemyDrawn = enemyDrawn.map((d, i) => {
            return { ...d, order: i };
          });
        }

        function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }
        function makeCard(n, enemy) {
          let factor = enemy ? -1 : 1;
          if (n === "legion") {
            return {
              enemy: enemy,
              name: n,
              attackPattern: [{ x: 0, y: -1 * factor }],
              movePattern: [{ x: 0, y: -1 * factor }],
            };
          }
          if (n === "archer") {
            return {
              enemy: enemy,
              name: n,
              attackPattern: [{ x: 0, y: -2 * factor }],
              movePattern: [{ x: 0, y: -1 * factor }],
            };
          }
          if (n === "shield") {
            return {
              enemy: enemy,
              name: n,
              attackPattern: [],
              movePattern: [{ x: 0, y: -1 * factor }],
            };
          }
          if (n === "berserk") {
            return {
              enemy: enemy,
              name: n,
              attackPattern: [{ x: 0, y: -1 * factor }],
              movePattern: [
                { x: 0, y: -1 * factor },
                { x: 0, y: -1 * factor },
              ],
            };
          }
          if (n === "knight") {
            return {
              enemy: enemy,
              name: n,
              attackPattern: [{ x: 0, y: -1 * factor }],
              movePattern: [
                { x: 0, y: -1 * factor },
                { x: 0, y: -1 * factor },
              ],
            };
          }
        }
        function drawGrid(ctx) {
          ctx.strokeStyle = "black";
          for (let x = 10; x < 600; x += 100) {
            ctx.beginPath();
            ctx.moveTo(x, 10);
            ctx.lineTo(x, 510);
            ctx.stroke();
          }
          for (let y = 10; y < 520; y += 100) {
            ctx.beginPath();
            ctx.moveTo(10, y);
            ctx.lineTo(510, y);
            ctx.stroke();
          }
          if (overlainGridBox) {
            let pos = grid2Pixel(overlainGridBox);
            ctx.fillStyle = overlainGridBox.color;
            ctx.fillRect(pos.x, pos.y, 100, 100);
          }
          ctx.fillStyle = "blue";
          ctx.fillRect(610, 200, 100, 100);
          ctx.fillStyle = "white";
          ctx.fillText("next turn", 610 + 20, 200 + 40);
          combatLog.splice(0, combatLog.length - 3);
          ctx.fillStyle = "black";
          combatLog.forEach((s, i) => {
            ctx.fillText(s, 520, 320 + i * 20);
          });
          ctx.fillText("HP: " + enemyHp, 520, 50);
          ctx.fillText("HP: " + yourHp, 520, 500);
        }

        function grid2Pixel(gridPos) {
          let x = gridPos.x * 100 + 10;
          let y = gridPos.y * 100 + 10;
          return { x: x, y: y };
        }
        function cleanAndRender(canvas) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          render();
        }

        function getMousePos(canvas, evt) {
          var rect = canvas.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top,
          };
        }

        canvas.addEventListener(
          "mousemove",
          function (evt) {
            var mousePos = getMousePos(canvas, evt);
            //what state are we in?
            let gridBox = gridIndex(mousePos.x, mousePos.y);
            overlainGridBox = undefined;
            overlainTroopBox = undefined;
            if (gridBox) {
              overlainGridBox = { ...gridBox, color: "rgb(255,0,0,0.3)" };
              //check if there is a troop here. if so, do the overlain troop box
              let troopAtGridPoint = troops.find(
                (t) => t.x === gridBox.x && t.y === gridBox.y
              );
              if (troopAtGridPoint) {
                overlainTroopBox = {
                  ...overlainGridBox,
                  ...troopAtGridPoint,
                };
              }
            }

            if (currentstate === "consider_card") {
              //CHECK GRID AND PLACE
              if (gridBox) {
                overlainTroopBox = {
                  ...overlainGridBox,
                  ...selectedCard,
                };
                if (gridBox.y === 4) {
                  overlainGridBox = {
                    ...overlainGridBox,
                    color: "rgb(0,255,0,0.3)",
                  };
                }
              }
              //check grid and paint overlay(s)
            }
            cleanAndRender(canvas);
          },
          false
        );
        canvas.addEventListener(
          "mousedown",
          function (evt) {
            //did we press next turn?
            var mousePos = getMousePos(canvas, evt);
            ctx.fillRect(610, 200, 100, 100);
            if (
              mousePos.x > 610 &&
              mousePos.x < 710 &&
              mousePos.y > 200 &&
              mousePos.y < 300
            ) {
              nextTurn();
              return;
            }
            drawn = drawn.map((d) => {
              return { ...d, filled: false };
            });
            //what state are we in?
            if (currentstate === "choose_card") {
              selectedCard = undefined;
              let card = cardIndex(mousePos.x, mousePos.y);
              if (card === 0 || card) {
                drawn[card] = { ...drawn[card], filled: true };
                currentstate = "consider_card";
                selectedCard = drawn[card];
              }
            } else if (currentstate === "consider_card") {
              let card = cardIndex(mousePos.x, mousePos.y);
              let grid = gridIndex(mousePos.x, mousePos.y);
              if (card === 0 || card) {
                drawn[card] = { ...drawn[card], filled: true };
                selectedCard = drawn[card];
              } else if (grid) {
                if (grid.y === 4 && selectedCard) {
                  troops.push({
                    enemy: false,
                    ...selectedCard,
                    ...grid,
                  });
                  let selectedCardIndex = drawn.findIndex(
                    (d) => d.order === selectedCard.order
                  );
                  discard.push(drawn.splice(selectedCardIndex, 1)[0]);
                }
                currentstate = "choose_card";
              } else {
                selectedCard = undefined;
                currentstate = "choose_card";
              }
            }
            cleanAndRender(canvas);
          },
          false
        );

        function placeEnemyTroops() {
          let troopsToPlace = enemyDrawn.splice(0, 3);
          troopsToPlace.forEach((enemyCard, i) => {
            let index = i === 0 ? 0 : i === 1 ? 2 : 4;
            troops.push({ ...enemyCard, x: index, y: 0 });
          });
          enemyDiscard.push(...troopsToPlace);
        }

        async function nextTurn() {
          console.log(enemyDrawn);
          console.log(enemyDiscard);
          discard = [...discard, ...drawn];
          enemyDiscard = [...enemyDiscard, ...enemyDrawn];
          drawCards(ctx, cards, discard);
          drawEnemyCards();
          //attack with all troops
          troops.sort((a, b) => b.x - a.x);
          troops.sort((a, b) => (a.enemy ? (b.enemy ? 0 : 1) : -1));
          await moveAndAttackTroops(troops.filter((t) => t.enemy));
          if (yourHp < 1) {
            endGame();
            return;
          }
          await moveAndAttackTroops(troops.filter((t) => !t.enemy));
          if (enemyHp < 1) {
            endGame();
            return;
          }
          placeEnemyTroops();
          currentstate = "choose_card";
          cleanAndRender(canvas);
        }

        function endGame() {
          gameOverText = yourHp < 1 ? "YOU LOSE" : "YOU WIN";
          cleanAndRender(canvas);
        }

        async function moveAndAttackTroops(theseTroops) {
          await attackTroops(theseTroops);
          await moveTroops(theseTroops);
        }

        async function attackTroops(theseTroops) {
          const timer = () => new Promise((res) => setTimeout(res, 300));

          for (let i = 0; i < theseTroops.length; i++) {
            let troop = theseTroops[i];
            let enemyDamage = enemyDamageFromPos(troop, troop);
            for (let j = 0; j < troop.attackPattern.length; j++) {
              let p = troop.attackPattern[j];
              const newPos = { x: troop.x + p.x, y: troop.y + p.y };
              let troopAtGridPoint = troops.find(
                (t) => t.x === newPos.x && t.y === newPos.y
              );
              //attack!
              if (troopAtGridPoint) {
                troops = troops.filter(
                  (t) => t.x !== newPos.x || t.y !== newPos.y
                );
                combatLog.push("Killed " + troopAtGridPoint.name);
                cleanAndRender(canvas);
                await timer();
              }
            }
            if (enemyDamage > 0) {
              if (troop.enemy) {
                yourHp -= enemyDamage;
                combatLog.push("you: " + enemyDamage + " dmg");
              } else {
                enemyHp -= enemyDamage;
                combatLog.push("enemy: " + enemyDamage + " dmg");
              }
              cleanAndRender(canvas);
              await timer();
            }
          }
        }

        async function moveTroops(theseTroops) {
          const timer = () => new Promise((res) => setTimeout(res, 300));

          //move all troops
          for (let i = 0; i < theseTroops.length; i++) {
            let troop = theseTroops[i];
            for (let j = 0; j < troop.movePattern.length; j++) {
              let p = troop.movePattern[j];
              const newPos = { x: troop.x + p.x, y: troop.y + p.y };
              let troopAtGridPoint = troops.find(
                (t) => t.x === newPos.x && t.y === newPos.y
              );
              let enemyInRange = enemyDamageFromPos(troop, troop) > 0;
              if (!troopAtGridPoint && !enemyInRange) {
                troop.x = newPos.x;
                troop.y = newPos.y;
              }
              cleanAndRender(canvas);
              await timer();
            }
          }
        }

        function enemyDamageFromPos(troop, position) {
          // if this troop is at position, can it hit the enemy?
          // i.e how many of its hit boxes have y > 4?
          return troop.attackPattern
            .map((p) => {
              let yPos = position.y + p.y;
              let hit = troop.enemy ? yPos > 4 : yPos < 0;
              return hit ? 1 : 0;
            })
            .reduce((a, p) => a + p, 0);
        }

        function gridIndex(x, y) {
          if (y > 10 && y < 510 && x > 10 && x < 510) {
            // find row
            let row, column;
            for (let i = 0; i < 5; i++) {
              let rowStart = i * 100 + 10;
              let rowEnd = rowStart + 100;
              if (y > rowStart && y < rowEnd) {
                row = i;
              }
            }
            for (let i = 0; i < 5; i++) {
              let colStart = i * 100 + 10;
              let colEnd = colStart + 100;
              if (x > colStart && x < colEnd) {
                column = i;
              }
            }
            return { x: column, y: row };
          }
        }

        function cardIndex(x, y) {
          if (y > 520 && y < 620) {
            const width = 60;
            for (let i = 0; i < drawn.length; i++) {
              let leftSide = i * 100 + 30;
              let rightSide = leftSide + 60;
              if (x > leftSide && x < rightSide) {
                return i;
              }
            }
          }
        }
      };
    </script>
  </body>
</html>
